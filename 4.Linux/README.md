## 1_1
	Проверяем значение переменной UID.
	Если равно 0 - это рут.
	Иначе - не рут.

## 1_2
	С помощью read -p выводим сообщение о ожидании ввода.
	С помощью read читаем ввод в переменную STR.

## 1_3
	Запускаем 2 процесса.
	1) Ждёт 5 секунд. Если после этого в ps есть процесс с 2мя pid-ами скрипта, то убиваем эти процессы.
	2) Просим пользователя произвести ввод. 

## 1_4_1 и 1_4_2
	dete +$j - время с начала года
	dete +$s - время с начала эпохи UNIX

## 1_5
	В цикле печатает первый переданный аргумент.
	После этого sift смещает влево параметры.
	Снова печатаем первый аргумент (он уже новый, после shift-а)

## 1_6
	При вводе можно было бы воспользоваться read -n 1, что позволяло бы ввести единственный символ, но, т.к. в задании требуется проверка, то реализуем скрипт, который считывает строку любой длины.
	Читаем строку. Проверяем, если она состоит более чем из 1 символа - выводим ошибку.
	Если символ один, с помощью case проверяем, какому промежутку он принадлежит.
	[a-z] - буквы нижнего регистра.
	[A-Z] - буквы верхнего регистра.
	.,;:- - знаки припинания
	Пробел - ''
	Всё остальное - другое.
	После этого добавили поддержку русского языка.
	Вначале планировалось просто расширить промежутки [а-яa-z] и [А-ЯA-Z].
	Но после этого программа вела себя не так, как ожидалось.
	При вводе большой русской буквы А вывод показывал, что введена маленькая буква.
	Для решения этой проблемы вместео [а-я] была использована строка, которая содержит все буквы русского языка в нижнем регистре: "йцукенгшщзхъфывапролджэячсмитьбю". 

## 1_7
	$1 - метры, которые нужно перевести в мили.
	X - мили/метры.
	scale=5 - кол-во цифр после точки (для bc)
	Отдаем строку bc с помощью пайпа.
	bc считает и выводит ответ.
__Пример использования (для 1 метра):__  
`bash 1_7.sh 1`  
`.00062`  

## 1_8
	Запускаем цикл от 1 до 700 (seq 1 700) [это 700 повторений]
	Используем $RANDOM для генирации случайного числа.
	Делим полученное число на 6 и получаем его остаток = [0;5].
	Прибавляем единицу, таким образом получаем интервал, в котором находятся значения шестигранного кубика = [1;6].
	С помощью case определяем, какое число выпало.
	Далее увиличиваем соответствующую переменную на 1.

## 1_3_1
	Вначале проверяем параметры командной строки.
	Если ничего не было передано, просим ввести "USD" или "EUR".
	В программе не реализована проверка на корректность вводим данных, т.к. по условию она не требуется.
	После этого сопоставляем временную переменную Х префиксу для URL адреса.
	Например, для USD: URL адрес сайта будет заканчиваться на usd-byn.
	После этого инициализируем переменную URL_SITE.
	Далее выполняем команды через пайпы:
		wget для чтения веб-страницы
			--quiet     убирает вывод информации о работе wget.
			-O - 	    переводит вывод wget в стандартный поток вывода.
		grep для нахождения строки по шаблону
			-E          для работы с HTML/CSS
			-o          вывод в стандартный поток
			Шаблон поиска: '<span class=\"text-2xl[^>]*>([^<]*)<\/span>'
		sed для получения значения курса валюты из строки с сайта
			Шаблон: 's/^.*<span[^>]*>//;s/<.*//'
			Вначале удаляем открывающий тег span; после этого удаляем закрывающий тег. 
    После этого мы получаем актуальное значение искомого курса.
	После этого выводим используемый прификс и полученный с сайта курс. 

## 1_3_2
	Для начала инициализируем переменную USER_AGENT, чтобы скрипт притворялся браузером.
	Внашем случае - мозилой.
	Хотя скрипт работал из без изменения юзер агента, но при это иногда приходили сообщения, что неизвестный совершил вход в почту.
	Хотя этих сообщениях пишут:"Знания пароля не всегда достаточно, чтобы попасть в аккаунт — в некоторых случаях Яндекс проводит дополнительную проверку",- скрипт ни разу испытывал трудностей с авторизацией.
	После этого отправляем с помощью wget данные для post-запроса с логином и паролем.
	Для этого смотрим поле name в HTML-разметке страницы авторизации.
	Сохраняем куки в отдельный файл для будущего использования.
	После этого заходим с помощью wget на страницу почты, используем полученные куки, чтобы подтвердить Яндексу то, что мы авторизованы.
	Сохраняем куки этого сеанса - требуется по условию.
	Передаем полученную страницу по пайпам для grep-а и ищем по шаблону HTML-контейнеры в которых лежат сообщения.
		Шаблон: <span class="b-messages__firstline">[^<]*<\/span>
	После этого с помощью wc -l считаем количество полученных строк.
	Далее, удаляем куки, полученные на первом шагу.
	После этого выводим в консоль количество входящих сообщений. 
		PS: в скрипте не реализован ввод пароля и логина пользователя.
		Для проверки работоспособности скрипта использовалась тестовая почта.